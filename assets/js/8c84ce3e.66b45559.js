"use strict";(globalThis.webpackChunkfront_end=globalThis.webpackChunkfront_end||[]).push([[664],{7848:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"chapter-2-ros2","title":"chapter-2-ros2","description":"Chapter 2: The Robotic Nervous System (ROS 2)","source":"@site/docs/chapter-2-ros2.md","sourceDirName":".","slug":"/chapter-2-ros2","permalink":"/robotics-book/docs/chapter-2-ros2","draft":false,"unlisted":false,"editUrl":"https://github.com/amnaMahmoodObs/robotics-book/tree/main/front-end/docs/chapter-2-ros2.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 1: Introduction to Physical AI & Humanoid Robotics","permalink":"/robotics-book/docs/chapter-1-introduction"},"next":{"title":"Chapter 3: The Digital Twin: Gazebo & Unity for Physical AI","permalink":"/robotics-book/docs/chapter-3-digital-twin"}}');var o=i(4848),r=i(8453);const t={},a=void 0,l={},c=[{value:"1. Introduction to ROS 2",id:"1-introduction-to-ros-2",level:2},{value:"Why Do We Need ROS 2?",id:"why-do-we-need-ros-2",level:3},{value:"Key Advantages of ROS 2",id:"key-advantages-of-ros-2",level:3},{value:"2. ROS 2 Nodes, Topics, and Services",id:"2-ros-2-nodes-topics-and-services",level:2},{value:"Nodes: The Building Blocks",id:"nodes-the-building-blocks",level:3},{value:"Topics: Asynchronous Communication",id:"topics-asynchronous-communication",level:3},{value:"Services: Synchronous Communication",id:"services-synchronous-communication",level:3},{value:"Actions: For Long-Running Tasks",id:"actions-for-long-running-tasks",level:3},{value:"Parameters: Node Configuration",id:"parameters-node-configuration",level:3},{value:"3. Python Agents and rclpy Integration",id:"3-python-agents-and-rclpy-integration",level:2},{value:"Introducing <code>rclpy</code>",id:"introducing-rclpy",level:3},{value:"Creating a Simple ROS 2 Node in Python",id:"creating-a-simple-ros-2-node-in-python",level:3},{value:"Simple Python Publisher Example",id:"simple-python-publisher-example",level:3},{value:"Simple Python Subscriber Example",id:"simple-python-subscriber-example",level:3},{value:"4. Understanding URDF for Humanoids",id:"4-understanding-urdf-for-humanoids",level:2},{value:"What is URDF?",id:"what-is-urdf",level:3},{value:"Key Elements of URDF",id:"key-elements-of-urdf",level:3},{value:"Why is URDF Important for Humanoids?",id:"why-is-urdf-important-for-humanoids",level:3},{value:"Basic URDF Structure Example",id:"basic-urdf-structure-example",level:3}];function d(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"Chapter 2: The Robotic Nervous System (ROS 2)"}),"\n",(0,o.jsx)(n.h2,{id:"1-introduction-to-ros-2",children:"1. Introduction to ROS 2"}),"\n",(0,o.jsx)(n.p,{children:"Imagine a complex robot with many different parts: cameras for seeing, motors for moving, sensors for feeling, and a brain to make decisions. How do all these independent parts talk to each other and work together seamlessly? This is where ROS 2 comes in."}),"\n",(0,o.jsx)(n.p,{children:"ROS 2, which stands for Robot Operating System 2, is not an operating system like Windows or macOS. Instead, it's a flexible framework for writing robot software. Think of it as a set of tools, libraries, and conventions that help different pieces of robot software communicate and operate together. It provides a standardized way for various components of a robot to send and receive information, enabling sophisticated robotic applications."}),"\n",(0,o.jsx)(n.h3,{id:"why-do-we-need-ros-2",children:"Why Do We Need ROS 2?"}),"\n",(0,o.jsx)(n.p,{children:"Developing robots is incredibly complex. A single robot can have dozens of components, each needing to perform a specific task and share data with others. ROS 2 addresses this complexity by:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Modularity:"})," It allows you to break down a robot's functionalities into small, independent programs. This makes development easier, as different teams or individuals can work on different parts of the robot without interfering with each other."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Communication:"})," It provides robust mechanisms for these independent programs to communicate with each other, whether they are running on the same computer or across multiple computers."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Ecosystem:"})," It comes with a vast collection of tools, libraries, and an active community that supports development, simulation, and deployment of robotic systems."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"key-advantages-of-ros-2",children:"Key Advantages of ROS 2"}),"\n",(0,o.jsx)(n.p,{children:"ROS 2 was built from the ground up to address limitations of its predecessor (ROS 1) and to meet the demands of modern robotics. Some of its key advantages include:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Real-time Capabilities:"})," Improved performance and determinism, crucial for applications requiring precise timing and control."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Distributed Systems:"})," Better support for running robot components across multiple machines, which is common in advanced robotic setups."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Security:"})," Enhanced security features to protect robotic systems from unauthorized access or malicious attacks."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Platform Independence:"})," It can run on various operating systems, including Linux, Windows, and macOS."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:'Suggested Image Idea: A diagram showing various robot components (camera, motor, sensor) connected by lines converging into a central "ROS 2" cloud, illustrating how it facilitates communication.'}),"\n",(0,o.jsx)(n.h2,{id:"2-ros-2-nodes-topics-and-services",children:"2. ROS 2 Nodes, Topics, and Services"}),"\n",(0,o.jsx)(n.p,{children:"At the heart of ROS 2's communication architecture are concepts like Nodes, Topics, and Services. Understanding these is fundamental to building any ROS 2 application."}),"\n",(0,o.jsx)(n.h3,{id:"nodes-the-building-blocks",children:"Nodes: The Building Blocks"}),"\n",(0,o.jsxs)(n.p,{children:["A ",(0,o.jsx)(n.strong,{children:"Node"})," is essentially an executable program that performs a specific task within the ROS 2 ecosystem. Think of it as a small, specialized application. For example:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"A camera node might capture images."}),"\n",(0,o.jsx)(n.li,{children:"A motor control node might send commands to the robot's wheels."}),"\n",(0,o.jsx)(n.li,{children:"A navigation node might calculate the robot's path."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Nodes are designed to be independent and can run simultaneously. Each node typically focuses on a single, well-defined function."}),"\n",(0,o.jsx)(n.h3,{id:"topics-asynchronous-communication",children:"Topics: Asynchronous Communication"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Topics"}),' are the primary way nodes exchange data in a one-way, asynchronous manner. This is often described as a "publish/subscribe" model:']}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Publishers:"}),' A node that sends data to a topic is called a publisher. It "publishes" messages onto a specific topic.']}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Subscribers:"}),' A node that wants to receive data from a topic is called a subscriber. It "subscribes" to a topic to get messages.']}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"When a publisher sends a message, any node subscribed to that topic receives a copy of the message. This is ideal for continuous streams of data, like sensor readings or video feeds."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Message Types:"})," Every topic has a defined ",(0,o.jsx)(n.em,{children:"message type"}),", which dictates the structure and kind of data that can be sent over it (e.g., ",(0,o.jsx)(n.code,{children:"sensor_msgs/Image"})," for camera images, ",(0,o.jsx)(n.code,{children:"std_msgs/String"})," for simple text)."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:'Suggested Image Idea: A diagram illustrating two nodes (Node A and Node B). Node A has an arrow pointing to a "Topic: Sensor Data" box, and Node B has an arrow pointing from the "Topic: Sensor Data" box, showing the flow of information.'}),"\n",(0,o.jsx)(n.h3,{id:"services-synchronous-communication",children:"Services: Synchronous Communication"}),"\n",(0,o.jsxs)(n.p,{children:["While topics are great for continuous data streams, sometimes you need a node to request a specific action or information from another node and then wait for a response. This is where ",(0,o.jsx)(n.strong,{children:"Services"}),' come in. Services provide a synchronous "request/response" communication pattern:']}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Service Server:"})," A node that offers a particular service. It waits for requests."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Service Client:"})," A node that sends a request to a service server and waits for a response."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:'Imagine you want to ask a robot to perform a specific action, like "move to these coordinates." You would use a service client to send this request to a service server that handles robot movement. The client would then wait for the server to confirm that the movement is complete or if there was an error.'}),"\n",(0,o.jsx)(n.h3,{id:"actions-for-long-running-tasks",children:"Actions: For Long-Running Tasks"}),"\n",(0,o.jsxs)(n.p,{children:['For tasks that are more complex than a simple request/response (like "drive 10 meters forward" which takes time), ROS 2 introduces ',(0,o.jsx)(n.strong,{children:"Actions"}),". Actions are similar to services but provide feedback on the progress of a long-running goal, allow for cancellation, and return a final result. This is useful for navigation or robotic manipulation tasks."]}),"\n",(0,o.jsx)(n.h3,{id:"parameters-node-configuration",children:"Parameters: Node Configuration"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Parameters"})," are configuration values that nodes can access at runtime. They allow you to change a node's behavior without recompiling its code. For instance, a camera node might have a parameter for its resolution or frame rate."]}),"\n",(0,o.jsx)(n.h2,{id:"3-python-agents-and-rclpy-integration",children:"3. Python Agents and rclpy Integration"}),"\n",(0,o.jsxs)(n.p,{children:["Python is a popular language in robotics due to its readability, extensive libraries, and rapid prototyping capabilities. ROS 2 fully supports Python development through its client library, ",(0,o.jsx)(n.code,{children:"rclpy"}),"."]}),"\n",(0,o.jsxs)(n.h3,{id:"introducing-rclpy",children:["Introducing ",(0,o.jsx)(n.code,{children:"rclpy"})]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"rclpy"})," is the Python client library for ROS 2. It provides the necessary tools and functions to create ROS 2 nodes, publish and subscribe to topics, offer and request services, and interact with parameters, all using Python."]}),"\n",(0,o.jsx)(n.h3,{id:"creating-a-simple-ros-2-node-in-python",children:"Creating a Simple ROS 2 Node in Python"}),"\n",(0,o.jsxs)(n.p,{children:["Let's look at how to create a basic ROS 2 node using ",(0,o.jsx)(n.code,{children:"rclpy"}),". This node will simply print a message periodically."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\n\nclass MinimalPublisher(Node):\n    def __init__(self):\n        super().__init__('minimal_publisher')\n        self.publisher_ = self.create_publisher(String, 'topic', 10)\n        timer_period = 0.5  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.i = 0\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = 'Hello ROS 2: %d' % self.i\n        self.publisher_.publish(msg)\n        self.get_logger().info('Publishing: \\\"%s\\\"' % msg.data)\n        self.i += 1\n\ndef main(args=None):\n    rclpy.init(args=args) # Initialize ROS 2 communication\n    minimal_publisher = MinimalPublisher() # Create an instance of our node\n    rclpy.spin(minimal_publisher) # Keep the node alive\n    minimal_publisher.destroy_node() # Clean up when done\n    rclpy.shutdown() # Shut down ROS 2 communication\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.h3,{id:"simple-python-publisher-example",children:"Simple Python Publisher Example"}),"\n",(0,o.jsx)(n.p,{children:"In the code above:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"rclpy.init(args=args)"}),": Initializes the ROS 2 client library. This must be called before any other ",(0,o.jsx)(n.code,{children:"rclpy"})," functions."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Node('minimal_publisher')"}),": Creates a new ROS 2 node named ",(0,o.jsx)(n.code,{children:"minimal_publisher"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"self.create_publisher(String, 'topic', 10)"}),": Creates a publisher that will send messages of type ",(0,o.jsx)(n.code,{children:"std_msgs/String"})," on a topic named ",(0,o.jsx)(n.code,{children:"'topic'"}),". The ",(0,o.jsx)(n.code,{children:"10"})," is the queue size."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"self.create_timer(timer_period, self.timer_callback)"}),": Sets up a timer to call ",(0,o.jsx)(n.code,{children:"timer_callback"})," every ",(0,o.jsx)(n.code,{children:"0.5"})," seconds."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"self.publisher_.publish(msg)"}),": Sends the message."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"rclpy.spin(minimal_publisher)"}),": Keeps the node running, allowing it to process callbacks and communicate with other ROS 2 entities."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"simple-python-subscriber-example",children:"Simple Python Subscriber Example"}),"\n",(0,o.jsxs)(n.p,{children:["Here's how you would create a corresponding subscriber node to receive messages from the ",(0,o.jsx)(n.code,{children:"'topic'"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass MinimalSubscriber(Node):\n    def __init__(self):\n        super().__init__('minimal_subscriber')\n        self.subscription = self.create_subscription(\n            String,\n            'topic',\n            self.listener_callback,\n            10)\n        self.subscription  # prevent unused variable warning\n\n    def listener_callback(self, msg):\n        self.get_logger().info('I heard: \\\"%s\\\"' % msg.data)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_subscriber = MinimalSubscriber()\n    rclpy.spin(minimal_subscriber)\n    minimal_subscriber.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.p,{children:"In the subscriber code:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"self.create_subscription(String, 'topic', self.listener_callback, 10)"}),": Creates a subscriber that listens to messages of type ",(0,o.jsx)(n.code,{children:"std_msgs/String"})," on the ",(0,o.jsx)(n.code,{children:"'topic'"}),". When a message arrives, it calls ",(0,o.jsx)(n.code,{children:"listener_callback"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Suggested Image Idea: Two Python code blocks side-by-side, one for the publisher and one for the subscriber, with arrows indicating data flow from publisher to topic and from topic to subscriber."}),"\n",(0,o.jsx)(n.h2,{id:"4-understanding-urdf-for-humanoids",children:"4. Understanding URDF for Humanoids"}),"\n",(0,o.jsxs)(n.p,{children:["For a robot to exist in a simulated environment or to be visualized effectively, we need a way to describe its physical structure. This is where ",(0,o.jsx)(n.strong,{children:"URDF"})," comes in."]}),"\n",(0,o.jsx)(n.h3,{id:"what-is-urdf",children:"What is URDF?"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"URDF"})," stands for ",(0,o.jsx)(n.strong,{children:"Unified Robot Description Format"}),". It's an XML-based file format used in ROS 2 (and ROS 1) to describe the physical characteristics of a robot. This includes:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Its geometric and inertial properties."}),"\n",(0,o.jsx)(n.li,{children:"The connections between its rigid body parts (links)."}),"\n",(0,o.jsx)(n.li,{children:"The types of joints that connect these parts and their limits."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Essentially, a URDF file is a detailed blueprint of your robot's body."}),"\n",(0,o.jsx)(n.h3,{id:"key-elements-of-urdf",children:"Key Elements of URDF"}),"\n",(0,o.jsx)(n.p,{children:"A URDF file is primarily composed of two main elements:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsxs)(n.strong,{children:[(0,o.jsx)(n.code,{children:"<link>"}),":"]})," Represents a rigid body part of the robot. This could be a robot's torso, a leg segment, a wheel, or a sensor housing. Each link has properties like its visual appearance, collision geometry, and inertial characteristics (mass, center of mass)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsxs)(n.strong,{children:[(0,o.jsx)(n.code,{children:"<joint>"}),":"]})," Describes how two ",(0,o.jsx)(n.code,{children:"<link>"})," elements are connected and how they can move relative to each other. Joints define the robot's degrees of freedom. Common joint types include:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"revolute"}),": Allows rotation around a single axis (like an elbow)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"prismatic"}),": Allows linear motion along a single axis (like a linear actuator)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"fixed"}),": Connects two links rigidly, with no relative motion."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"why-is-urdf-important-for-humanoids",children:"Why is URDF Important for Humanoids?"}),"\n",(0,o.jsx)(n.p,{children:"Humanoid robots, with their many limbs, joints, and complex movements, greatly benefit from URDF:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Kinematic Chains:"})," URDF helps define the intricate kinematic chains of a humanoid, allowing software to calculate how different parts of the robot move in relation to each other."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Simulation:"})," Before building a physical robot, its URDF model can be loaded into simulation environments (like Gazebo) to test movements, control algorithms, and interactions with the environment."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Visualization:"})," Tools like RViz (ROS Visualization) use URDF files to display a 3D model of the robot, showing its current pose and sensor data in real-time. This is invaluable for debugging and understanding robot behavior."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"basic-urdf-structure-example",children:"Basic URDF Structure Example"}),"\n",(0,o.jsx)(n.p,{children:"Here's a simplified conceptual example of what a URDF snippet might look like for a very basic two-link arm:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_arm">\n  <link name="base_link">\n    \x3c!-- Visual, collision, and inertial properties of the base --\x3e\n  </link>\n\n  <joint name="shoulder_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="upper_arm_link"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-1.57" upper="1.57" velocity="1.0" effort="10.0"/>\n  </joint>\n\n  <link name="upper_arm_link">\n    \x3c!-- Visual, collision, and inertial properties of the upper arm --\x3e\n  </link>\n</robot>\n'})}),"\n",(0,o.jsx)(n.p,{children:"In this example:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"base_link"})," and ",(0,o.jsx)(n.code,{children:"upper_arm_link"})," are the rigid parts."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"shoulder_joint"})," is a revolute joint that connects the ",(0,o.jsx)(n.code,{children:"base_link"})," (parent) to the ",(0,o.jsx)(n.code,{children:"upper_arm_link"})," (child), allowing rotation around the Z-axis."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["For more complex robots, especially humanoids, ",(0,o.jsx)(n.code,{children:"xacro"})," (XML Macros) is often used with URDF. ",(0,o.jsx)(n.code,{children:"xacro"})," allows for more concise and modular URDF files by using macros and mathematical expressions, making it easier to manage the many links and joints found in humanoid designs."]}),"\n",(0,o.jsx)(n.p,{children:'Suggested Image Idea: A rendered 3D model of a simple robot arm or humanoid torso, with labels pointing to "links" and "joints" to illustrate their physical representation.'})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>a});var s=i(6540);const o={},r=s.createContext(o);function t(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);